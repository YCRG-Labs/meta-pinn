"""
Integration tests for FEniCSx solver with task generation system.
"""

import pytest
import numpy as np
import torch
from typing import Dict, List

from ml_research_pipeline.core.fenicsx_solver import (
    FEniCSxSolver, SolverConfig, create_fenicsx_solver, FENICSX_AVAILABLE
)
from ml_research_pipeline.core.task_generator import FluidTaskGenerator
from ml_research_pipeline.core.analytical_solutions import AnalyticalSolutionGenerator
from ml_research_pipeline.config.data_config import DataConfig, TaskConfig, ViscosityConfig, GeometryConfig


class TestFEniCSxTaskIntegration:
    """Test integration between FEniCSx solver and task generation system."""
    
    @pytest.mark.skipif(not FENICSX_AVAILABLE, reason="FEniCSx not available")
    def test_solver_with_generated_tasks(self):
        """Test FEniCSx solver with tasks generated by FluidTaskGenerator."""
        # Create task generator
        data_config = DataConfig(
            task_types=['linear_viscosity', 'exponential_viscosity'],
            domain_bounds={'x': (0.0, 1.0), 'y': (0.0, 1.0)},
            n_interior_points=50,
            n_boundary_points=20
        )
        
        viscosity_config = ViscosityConfig(
            base_viscosity_range=(0.01, 0.05),
            gradient_range=(-0.1, 0.1)
        )
        
        geometry_config = GeometryConfig(
            geometry_type='channel',
            length=1.0,
            width=1.0
        )
        
        task_generator = FluidTaskGenerator(
            data_config=data_config,
            viscosity_config=viscosity_config,
            geometry_config=geometry_config,
            seed=42
        )
        
        # Generate a small batch of tasks
        tasks = task_generator.generate_task_batch(
            batch_size=2,
            n_support=10,
            n_query=5
        )
        
        # Create FEniCSx solver
        solver_config = SolverConfig(mesh_resolution=(8, 8), tolerance=1e-4)
        solver = FEniCSxSolver(solver_config)
        
        # Test solving each generated task
        for task in tasks:
            # Use the query coordinates from the task
            coords = task.query_set['coords']
            
            # Solve with FEniCSx
            solution = solver.solve_task(task.config, coords)
            
            # Basic validation
            assert solution.velocity.shape == (len(coords), 2)
            assert solution.pressure.shape == (len(coords), 1)
            assert solution.viscosity_field.shape == (len(coords), 1)
            
            # Check that solution is finite
            assert torch.all(torch.isfinite(solution.velocity))
            assert torch.all(torch.isfinite(solution.pressure))
            assert torch.all(torch.isfinite(solution.viscosity_field))
            
            # Check metadata
            assert solution.metadata['task_id'] == task.config.task_id
            assert 'solution_type' in solution.metadata
    
    @pytest.mark.skipif(not FENICSX_AVAILABLE, reason="FEniCSx not available")
    def test_solver_analytical_comparison(self):
        """Test FEniCSx solver against analytical solutions for simple cases."""
        # Create analytical solution generator
        analytical_generator = AnalyticalSolutionGenerator()
        
        # Create FEniCSx solver
        solver_config = SolverConfig(mesh_resolution=(12, 8), tolerance=1e-5)
        solver = FEniCSxSolver(solver_config)
        
        # Test simple channel flow with constant viscosity
        config = TaskConfig(
            task_id="integration_test_001",
            task_type="linear_viscosity",
            geometry_type="channel",
            reynolds_number=0.5,  # Low Reynolds for better agreement
            viscosity_params={'base_viscosity': 0.1},
            geometry_params={'length': 1.0, 'width': 1.0, 'inlet_profile': 'uniform'},
            boundary_conditions={
                'inlet': {'type': 'dirichlet', 'value': [0.05, 0.0]},
                'walls': {'type': 'dirichlet', 'value': [0.0, 0.0]}
            },
            density=1.0
        )
        
        # Create evaluation coordinates
        coords = torch.tensor([
            [0.2, 0.2], [0.2, 0.5], [0.2, 0.8],
            [0.5, 0.2], [0.5, 0.5], [0.5, 0.8],
            [0.8, 0.2], [0.8, 0.5], [0.8, 0.8]
        ])
        
        # Generate analytical solution
        analytical_solution = analytical_generator.generate_solution(
            config, coords, solution_type='poiseuille_flow'
        )
        
        # Solve with FEniCSx
        fenicsx_solution = solver.solve_task(config, coords)
        
        # Compare solutions
        velocity_diff = torch.norm(fenicsx_solution.velocity - analytical_solution.velocity, dim=1)
        pressure_diff = torch.abs(fenicsx_solution.pressure - analytical_solution.pressure).squeeze()
        
        # Check that differences are reasonable
        max_velocity_error = torch.max(velocity_diff).item()
        max_pressure_error = torch.max(pressure_diff).item()
        
        # These are loose bounds since we're comparing different solution methods
        assert max_velocity_error < 1.0  # Velocity error should be reasonable
        assert max_pressure_error < 10.0  # Pressure can have larger errors
        
        # Check that both solutions have similar characteristics
        fenicsx_u_max = torch.max(fenicsx_solution.velocity[:, 0]).item()
        analytical_u_max = torch.max(analytical_solution.velocity[:, 0]).item()
        
        # Maximum velocities should be in the same order of magnitude
        assert 0.1 < fenicsx_u_max / analytical_u_max < 10.0
    
    def test_solver_fallback_behavior(self):
        """Test that solver provides fallback solutions when FEniCSx fails."""
        # This test works regardless of FEniCSx availability
        solver_config = SolverConfig(mesh_resolution=(5, 5))
        
        if FENICSX_AVAILABLE:
            solver = FEniCSxSolver(solver_config)
        else:
            # Test the factory function behavior
            solver = create_fenicsx_solver(solver_config)
            if solver is None:
                pytest.skip("FEniCSx not available, skipping fallback test")
        
        # Create an invalid configuration that should trigger fallback
        invalid_config = TaskConfig(
            task_id="fallback_test_001",
            geometry_type="unsupported_geometry",  # This should cause an error
            reynolds_number=10.0,
            viscosity_params={'base_viscosity': 0.01}
        )
        
        coords = torch.tensor([[0.5, 0.5], [0.3, 0.7]])
        
        # Should return fallback solution instead of crashing
        solution = solver.solve_task(invalid_config, coords)
        
        # Check fallback solution properties
        assert solution.velocity.shape == (len(coords), 2)
        assert solution.pressure.shape == (len(coords), 1)
        assert solution.viscosity_field.shape == (len(coords), 1)
        
        # Fallback solution should be zeros or reasonable defaults
        assert torch.all(torch.isfinite(solution.velocity))
        assert torch.all(torch.isfinite(solution.pressure))
        assert torch.all(torch.isfinite(solution.viscosity_field))
        
        # Check metadata indicates fallback
        assert solution.metadata['solution_type'] == 'fenicsx_fallback'
        assert 'error_message' in solution.metadata
    
    @pytest.mark.skipif(not FENICSX_AVAILABLE, reason="FEniCSx not available")
    def test_batch_processing_integration(self):
        """Test batch processing of multiple tasks."""
        # Create multiple task configurations
        task_configs = []
        
        for i in range(3):
            config = TaskConfig(
                task_id=f"batch_integration_{i:03d}",
                task_type="linear_viscosity",
                geometry_type="channel",
                reynolds_number=1.0 + i * 0.5,
                viscosity_params={
                    'base_viscosity': 0.02 + i * 0.01,
                    'gradient_x': 0.0,
                    'gradient_y': i * 0.01
                },
                geometry_params={'length': 1.0, 'width': 1.0, 'inlet_profile': 'uniform'},
                boundary_conditions={
                    'inlet': {'type': 'dirichlet', 'value': [0.1 + i * 0.02, 0.0]},
                    'walls': {'type': 'dirichlet', 'value': [0.0, 0.0]}
                },
                density=1.0
            )
            task_configs.append(config)
        
        # Create solver
        solver_config = SolverConfig(mesh_resolution=(6, 6), tolerance=1e-4)
        solver = FEniCSxSolver(solver_config)
        
        # Test coordinates
        coords = torch.tensor([[0.2, 0.3], [0.5, 0.5], [0.8, 0.7]])
        
        # Solve batch
        solutions = solver.solve_task_batch(task_configs, coords)
        
        assert len(solutions) == len(task_configs)
        
        # Check each solution
        for i, solution in enumerate(solutions):
            assert solution.velocity.shape == (len(coords), 2)
            assert solution.pressure.shape == (len(coords), 1)
            assert solution.viscosity_field.shape == (len(coords), 1)
            
            assert torch.all(torch.isfinite(solution.velocity))
            assert torch.all(torch.isfinite(solution.pressure))
            assert torch.all(torch.isfinite(solution.viscosity_field))
            
            assert solution.metadata['task_id'] == f"batch_integration_{i:03d}"
            
            # Check that viscosity field matches expected linear variation
            coords_np = coords.numpy()
            y_coords = coords_np[:, 1]
            expected_viscosity = 0.02 + i * 0.01 + i * 0.01 * y_coords
            
            viscosity_values = solution.viscosity_field[:, 0]
            viscosity_error = torch.abs(viscosity_values - torch.from_numpy(expected_viscosity).float())
            max_error = torch.max(viscosity_error).item()
            
            # Should match closely since it's a simple linear profile
            assert max_error < 0.001
    
    @pytest.mark.skipif(not FENICSX_AVAILABLE, reason="FEniCSx not available")
    def test_ground_truth_dataset_generation(self):
        """Test generation of ground truth dataset for meta-learning."""
        # Create task configurations with different viscosity profiles
        task_configs = []
        
        # Linear viscosity task
        config1 = TaskConfig(
            task_id="dataset_linear_001",
            task_type="linear_viscosity",
            geometry_type="channel",
            reynolds_number=1.0,
            viscosity_params={
                'base_viscosity': 0.02,
                'gradient_x': 0.0,
                'gradient_y': 0.01
            },
            geometry_params={'length': 1.0, 'width': 1.0},
            boundary_conditions={
                'inlet': {'type': 'dirichlet', 'value': [0.1, 0.0]},
                'walls': {'type': 'dirichlet', 'value': [0.0, 0.0]}
            },
            density=1.0
        )
        
        # Exponential viscosity task
        config2 = TaskConfig(
            task_id="dataset_exp_001",
            task_type="exponential_viscosity",
            geometry_type="channel",
            reynolds_number=0.5,
            viscosity_params={
                'base_viscosity': 0.01,
                'decay_rate_x': 0.0,
                'decay_rate_y': 0.5,
                'amplitude': 1.0
            },
            geometry_params={'length': 1.0, 'width': 1.0},
            boundary_conditions={
                'inlet': {'type': 'dirichlet', 'value': [0.05, 0.0]},
                'walls': {'type': 'dirichlet', 'value': [0.0, 0.0]}
            },
            density=1.0
        )
        
        task_configs = [config1, config2]
        
        # Create solver
        solver_config = SolverConfig(mesh_resolution=(8, 8), tolerance=1e-4)
        solver = FEniCSxSolver(solver_config)
        
        # Generate ground truth dataset
        dataset = solver.generate_ground_truth_dataset(
            task_configs,
            n_points_per_task=15  # Small number for testing
        )
        
        # Validate dataset structure
        assert 'tasks' in dataset
        assert 'metadata' in dataset
        assert len(dataset['tasks']) == 2
        assert dataset['metadata']['n_tasks'] == 2
        assert dataset['metadata']['n_points_per_task'] == 15
        
        # Check each task in dataset
        for i, task_data in enumerate(dataset['tasks']):
            assert 'task_config' in task_data
            assert 'coordinates' in task_data
            assert 'velocity' in task_data
            assert 'pressure' in task_data
            assert 'viscosity_field' in task_data
            assert 'metadata' in task_data
            
            # Check data shapes
            assert task_data['coordinates'].shape == (15, 2)
            assert task_data['velocity'].shape == (15, 2)
            assert task_data['pressure'].shape == (15, 1)
            assert task_data['viscosity_field'].shape == (15, 1)
            
            # Check that data is finite
            assert np.all(np.isfinite(task_data['coordinates']))
            assert np.all(np.isfinite(task_data['velocity']))
            assert np.all(np.isfinite(task_data['pressure']))
            assert np.all(np.isfinite(task_data['viscosity_field']))
            
            # Check task configuration matches
            expected_task_id = f"dataset_{'linear' if i == 0 else 'exp'}_001"
            assert task_data['task_config']['task_id'] == expected_task_id


if __name__ == "__main__":
    pytest.main([__file__])